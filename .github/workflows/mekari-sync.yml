name: Mekari Jurnal Product Sync

on:
  schedule:
    # GitHub Actions uses UTC; 17:01 UTC = 00:01 WIB (UTC+7)
    - cron: "1 17 * * *"
  workflow_dispatch:
    inputs:
      reason:
        description: Optional reason for manual sync
        required: false
        default: manual-trigger

jobs:
  trigger-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve Mekari endpoint & token
        id: resolve-endpoint
        env:
          SECRET_ENDPOINT: ${{ secrets.MEKARI_SYNC_ENDPOINT }}
          SECRET_TOKEN: ${{ secrets.MEKARI_SYNC_TOKEN }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL || 'https://wnewbuwmdrnjfjsxoybs.supabase.co' }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InduZXdidXdtZHJuamZqc3hveWJzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExNjY3ODYsImV4cCI6MjA3Njc0Mjc4Nn0.8nTueW4ogLAXbbq0Q_Z6z-a8J5n9zIOhmlWIP7pimAg' }}
        run: |
          set -euo pipefail

          DEFAULT_BASE_URL="https://api.jurnal.id"
          DEFAULT_ENDPOINT="$DEFAULT_BASE_URL/partner/core/api/v1/products"

          ENDPOINT="${SECRET_ENDPOINT:-$DEFAULT_ENDPOINT}"
          TOKEN="${SECRET_TOKEN:-}"

          # If no token is provided, try to pull Mekari credentials from Supabase.
          if [ -z "$TOKEN" ] && [ -n "${SUPABASE_URL:-}" ] && [ -n "${SUPABASE_ANON_KEY:-}" ]; then
            echo "Fetching Mekari token from Supabase..."
            SUPABASE_RESPONSE=$(curl --fail --show-error --silent \
              "$SUPABASE_URL/rest/v1/api_integrations?name=eq.Mekari%20Jurnal&select=api_base_url,access_token&limit=1" \
              -H "apikey: $SUPABASE_ANON_KEY" \
              -H "Authorization: Bearer $SUPABASE_ANON_KEY")

            TOKEN_FROM_SUPABASE=$(printf '%s' "$SUPABASE_RESPONSE" | jq -r '.[0].access_token // empty')
            BASE_URL_FROM_SUPABASE=$(printf '%s' "$SUPABASE_RESPONSE" | jq -r '.[0].api_base_url // empty')

            if [ -n "$TOKEN_FROM_SUPABASE" ]; then
              TOKEN="$TOKEN_FROM_SUPABASE"
              echo "Mekari token resolved from Supabase."
            else
              echo "No Mekari token found in Supabase." >&2
            fi

            if [ "$ENDPOINT" = "$DEFAULT_ENDPOINT" ] && [ -n "$BASE_URL_FROM_SUPABASE" ]; then
              SANITIZED_BASE=$(printf '%s' "$BASE_URL_FROM_SUPABASE" | sed 's@/*$@@')
              if [ -n "$SANITIZED_BASE" ]; then
                ENDPOINT="$SANITIZED_BASE/partner/core/api/v1/products"
                echo "Endpoint updated from Supabase base URL: $ENDPOINT"
              fi
            fi
          fi

          if [ -z "$ENDPOINT" ]; then
            echo "::error::Set the MEKARI_SYNC_ENDPOINT secret or update the DEFAULT_ENDPOINT." >&2
            exit 1
          fi

          echo "endpoint=$ENDPOINT" >> "$GITHUB_OUTPUT"
          echo "token=$TOKEN" >> "$GITHUB_OUTPUT"

      - name: Trigger Mekari sync webhook
        env:
          ENDPOINT: ${{ steps.resolve-endpoint.outputs.endpoint }}
          TOKEN: ${{ steps.resolve-endpoint.outputs.token || secrets.MEKARI_SYNC_TOKEN }}
          EXTRA_HEADERS: ${{ secrets.MEKARI_SYNC_HEADERS }}
          METHOD: ${{ secrets.MEKARI_SYNC_METHOD || 'POST' }}
          REASON: ${{ github.event.inputs.reason || github.event_name }}
        run: |
          set -euo pipefail

          METHOD=$(printf '%s' "${METHOD:-POST}" | tr '[:lower:]' '[:upper:]')

          CURL_ARGS=("-X" "$METHOD" "$ENDPOINT" "-H" "Content-Type: application/json")

          if [ -n "${TOKEN:-}" ]; then
            CURL_ARGS+=("-H" "Authorization: Bearer $TOKEN")
          fi

          if [ -n "${EXTRA_HEADERS:-}" ]; then
            # EXTRA_HEADERS can contain additional header lines separated by \n
            while IFS= read -r header; do
              [ -z "$header" ] && continue
              CURL_ARGS+=("-H" "$header")
            done <<< "$EXTRA_HEADERS"
          fi

          PAYLOAD=$(jq -n --arg reason "$REASON" '{ trigger: "github-actions", reason: $reason, source: "entraverse" }')

          echo "Calling sync endpoint with method $METHOD..."
          HTTP_STATUS=$(curl --show-error --silent "${CURL_ARGS[@]}" -d "$PAYLOAD" -w "\n%{http_code}" -o /tmp/mekari-sync-response)

          RESPONSE_BODY=$(cat /tmp/mekari-sync-response || true)
          STATUS_CODE=$(printf '%s' "$HTTP_STATUS" | tail -n 1)

          if [[ "$STATUS_CODE" =~ ^2 ]]; then
            echo "Sync request submitted successfully (status: $STATUS_CODE)."
            if [ -n "$RESPONSE_BODY" ]; then
              echo "Response body:" && echo "$RESPONSE_BODY"
            fi
            exit 0
          fi

          echo "::error::Sync endpoint returned status $STATUS_CODE" >&2
          if [ -n "$RESPONSE_BODY" ]; then
            echo "Response body:" >&2
            echo "$RESPONSE_BODY" >&2
          else
            echo "No response body received." >&2
          fi

          echo "If you are using the default Mekari API endpoint, set MEKARI_SYNC_TOKEN (and method GET if required) or configure MEKARI_SYNC_ENDPOINT to point to your webhook." >&2
          exit 1
